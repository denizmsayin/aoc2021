#! /bin/bash

# TODO: Commandline options for skipping build, specific day etc.

current_target_prefix() {
  local lang=$(basename $(dirname $(pwd -P)))
  if [[ $lang == rust ]] && find Cargo.toml &> /dev/null; then
      echo "./target/release/part"
  elif [[ $lang == haskell ]]; then
      echo "./Part"
  else
      echo "./part"
  fi
}

# No links please (;
cd $(dirname "$0")

DAYS=$(ls -1 io)
LANGS="rust haskell c"
BUILD=false
GENERATE=false
TIMEOUT=15s

while getopts hbgl: opt; do
  case $opt in
    b)
      BUILD=true
      ;;
    l)
      LANGS=$OPTARG
      ;;
    g)
      GENERATE=true
      ;;
    h)
      echo "usage: $(basename $0) [-bh] [-l LANGS]"
      exit
      ;;
  esac
done

if $BUILD; then
  for lang in $LANGS; do
    echo "Compiling $lang code..."
    cd $lang
    for day in day??; do
      echo "$day"
      cd $day
      if [[ $lang == rust ]]; then
        if find Cargo.toml &> /dev/null; then
          cargo build
          cargo build --release
        else
          rustc part1.rs
          rustc part2.rs
        fi
      elif [[ $lang == haskell ]]; then
        ghc -Wall -O2 Part1.hs
        ghc -Wall -O2 Part2.hs
      else
        if [[ -f Makefile ]]; then
          make
        else
          gcc -Wall -O3 part1.c -o part1
          gcc -Wall -O3 part2.c -o part2
        fi
      fi
      cd ..
      echo
    done
    cd ..
  done
fi

declare -A results
declare -A mstimes
for lang in $LANGS; do
  cd $lang
  for day in day??; do
    cd $day
    iod="../../io/$day"
    for c in 1 2; do
      part="part$c"
      exe="$(current_target_prefix)$c"
      out=$(mktemp)
      start_time=$(date +%s%N)
      timeout -k "$TIMEOUT" "$TIMEOUT" $exe < "$iod"/input.txt > "$out"
      end_time=$(date +%s%N)
      if diff -w "$out" "$iod"/"$part"_output.txt &> /dev/null; then
        verdict='\033[32m+\033[0m'
        results[$lang,$day,$c]=1
        ms_time=$(((end_time - start_time) / 1000000))
        mstimes[$lang,$day,$c]=$ms_time
      else
        verdict='\033[31m-\033[0m'
        ms_time=0
      fi
      printf "%8s $day $part $verdict (%dms)\n" "$lang" "$ms_time"
      rm $out
    done
    cd ..
  done
  cd ..
done

if $GENERATE; then
  # Could do all in one loop by inverting previous, but meh!
  exec 5>&1
  exec 1>correctness.md

  cols="problem $LANGS"
  for header in $cols; do
    echo -n "| ${header^}"
  done
  echo "|"

  for _ in $cols; do
    echo -n "| :---: "
  done
  echo "|"

  for day in $DAYS; do
    for c in 1 2; do
      echo -n "| ${day^} - Part $c |"
      for lang in $LANGS; do
        if [[ ${results[$lang,$day,$c]} == 1 ]]; then
          echo -n " âœ… |"
        else
          echo -n "   |"
        fi
      done
      echo
    done
  done

  exec 1>mstimes.md

  cols="problem $LANGS"
  for header in $cols; do
    echo -n "| ${header^}"
  done
  echo "|"

  for _ in $cols; do
    echo -n "| :---: "
  done
  echo "|"

  for day in $DAYS; do
    for c in 1 2; do
      echo -n "| ${day^} - Part $c |"
      for lang in $LANGS; do
        if [[ ${results[$lang,$day,$c]} == 1 ]]; then
          ms_time=${mstimes[$lang,$day,$c]}
          check=$(bc <<< "$ms_time < 10")
          if [[ $check == 1 ]]; then
            echo -n " <10ms |"
          else
            echo -n " $ms_time""ms |"
          fi
        else
          echo -n " N/A |"
        fi
      done
      echo
    done
  done

  exec 1>README.md

  INCLUDE_REGEX='^@include[ \t]*([a-zA-Z0-9._-]+)$'
  while read ln; do
    if [[ $ln =~ $INCLUDE_REGEX ]]; then
      include_file=${BASH_REMATCH[1]}
      cat "$include_file"
    else
      echo $ln
    fi
  done < readme_template.md

  rm -f mstimes.md correctness.md

  exec 1>&5
fi
